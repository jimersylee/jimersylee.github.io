<?xml version="1.0" encoding="UTF-8"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Jimersy Lee's Blog</title>
        <description>这是Jimersy Lee的个人博客</description>
        <link>/</link>
        <atom:link href="//feed.xml" rel="self" type="application/rss+xml" />
        <pubDate>2017-09-12 10:09:05</pubDate>
        <lastBuildDate>2017-09-12 10:09:05</lastBuildDate>
        <generator>Gitblog v1.0</generator>
                <item>
            <title>PHP的Swoole扩展安装与学习</title>
            <description>
            &lt;!--
author: Jimersy Lee
head: 
date: 2017-09-08
title: PHP的Swoole扩展安装与学习
tags: PHP,SWOOLE
images: 
category: php
status: publish
summary: PHP的Swoole扩展安装与学习
--&gt;
&lt;h1&gt;安装swoole&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;#直接使用pecl安装扩展
sudo pecl install swoole
#检测是否安装成功
php -m|grep swoole
#如果有swoole则安装成功,否则,在php.ini中增加扩展
#获取php.ini的绝对路径
php -i |grep php.ini
cd  path
vim php.ini
#增加扩展
extension=swoole&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;跑测试例程&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;#创建文件
vim http_server.php

#输入代码
&amp;lt;?
$http = new swoole_http_server(&quot;0.0.0.0&quot;, 9501);

$http-&amp;gt;on('request', function ($request, $response) {
    var_dump($request-&amp;gt;get, $request-&amp;gt;post);
    $response-&amp;gt;header(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;);
    $response-&amp;gt;end(&quot;&amp;lt;h1&amp;gt;Hello Swoole. #&quot;.rand(1000, 9999).&quot;&amp;lt;/h1&amp;gt;&quot;);
});

$http-&amp;gt;start();

#启动程序
php http_server.php

#看看成功没有
curl http://127.0.0.1:9501

#如果正确输出,那就启动成功啦
&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2017-09-08 07:21:52</pubDate>
            <link>//blog/php/swoole.html</link>
            <guid isPermaLink="true">//blog/php/swoole.html</guid>
                                               <category>php</category>
                                    </item>
                <item>
            <title>我眼中规范的开发流程</title>
            <description>
            &lt;!--
author: Jimersy Lee
head: 
date: 2017-07-22
title: 我眼中规范的开发流程
tags: DEV,RULE
images: 
category: thoughts
status: publish
summary: 所谓没有规矩,不成方圆,就算是再小的团队,工作也需要规范的流程.
--&gt;
&lt;h2&gt;基于SVN的信息存储&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;存放开发文档&lt;/li&gt;
&lt;li&gt;存放测试用例&lt;/li&gt;
&lt;li&gt;存放三方对接文档&lt;/li&gt;
&lt;li&gt;存放同事的学习记录与分享&lt;/li&gt;
&lt;li&gt;存放会议纪要&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;测试&lt;/h2&gt;
&lt;h3&gt;完善的测试流程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;产品出文档测试即开始编写测试用例&lt;/li&gt;
&lt;li&gt;测试版本开发完成开始测试&lt;/li&gt;
&lt;li&gt;使用bugout进行记录与跟踪bug&lt;/li&gt;
&lt;li&gt;开发处理bug,在bugout上提交&lt;/li&gt;
&lt;li&gt;测试再次测试直到通过&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;构建&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;使用jenkin持续构建,单元测试,Sonar代码分析&lt;/li&gt;
&lt;li&gt;每个项目至少3个分支,dev,master,release分支&lt;/li&gt;
&lt;li&gt;测试在dev分支,预发布在master分支,线上使用release分支&lt;/li&gt;
&lt;li&gt;dev分支自动提交构建&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;平台架构&lt;/h1&gt;
&lt;p&gt;分布式的微服务架构&lt;/p&gt;
&lt;h1&gt;统一开发环境与工具&lt;/h1&gt;
&lt;p&gt;后端开发统一Jetbrains全家桶
接口调试使用Postman
文档使用showdoc&lt;/p&gt;            </description>
            <pubDate>2017-09-12 10:01:04</pubDate>
            <link>//blog/thoughts/dev-rule.html</link>
            <guid isPermaLink="true">//blog/thoughts/dev-rule.html</guid>
                                               <category>thoughts</category>
                                    </item>
                <item>
            <title>为域名配置免费SSL证书</title>
            <description>
            &lt;!--
author: Jimersy Lee
head: 
date: 2016-08-05
title: 为域名配置免费SSL证书
tags: NGINX,SSL
images: 
category: devops
status: publish
summary: 本文在CenOS主机上,使用腾讯云主机,以及阿里云域名服务,完成Nginx上指定的域名的ssl配置
--&gt;
&lt;h1&gt;Nginx配置ssl&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;腾讯云申请证书
&lt;img src=&quot;http://jimersyleetest.qiniudn.com/%E7%94%B3%E8%AF%B7%E8%AF%81%E4%B9%A6.png&quot; alt=&quot;申请证书&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://jimersyleetest.qiniudn.com/%E9%AA%8C%E8%AF%81%E8%AF%81%E4%B9%A6.png&quot; alt=&quot;选择验证方式&quot; /&gt;
&lt;img src=&quot;http://jimersyleetest.qiniudn.com/%E6%B7%BB%E5%8A%A0%E8%AE%B0%E5%BD%95.png&quot; alt=&quot;获得验证内容&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;阿里云域名解析验证证书
&lt;img src=&quot;http://jimersyleetest.qiniudn.com/%E8%A7%A3%E6%9E%90%E8%AE%BE%E7%BD%AE.png&quot; alt=&quot;解析&quot; /&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装证书&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下载证书&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上传配置证书&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#将本地的jenkins.jimersylee.com.zip上传至jimersylee.com这个机子上的/data/ssl_cert目录
scp jenkins.jimersylee.com.zip root@jimersylee.com:/data/ssl_cert
#登录主机解压文件
ssh root@jimersylee.com
cd /data/ssl_cert
unzip jenkins.jimersylee.com.zip
#各种web服务器的证书就解压完成了,然后去配置Nginx
[root@VM_77_132_centos ssl_cert]# tree
.
├── Apache
│   ├── 1_root_bundle.crt
│   ├── 2_blog.jimersylee.com.crt
│   ├── 2_jenkins.jimersylee.com.crt
│   ├── 2_jimersylee.com.crt
│   ├── 3_blog.jimersylee.com.key
│   ├── 3_jenkins.jimersylee.com.key
│   └── 3_jimersylee.com.key
├── blog.jimersylee.com.cert.zip
├── IIS
│   ├── blog.jimersylee.com.pfx
│   ├── jenkins.jimersylee.com.pfx
│   ├── jimersylee.com.pfx
│   └── keystorePass.txt
├── jenkins.jimersylee.com.zip
├── jimersylee.com.cert.zip
├── Nginx
│   ├── 1_blog.jimersylee.com_bundle.crt
│   ├── 1_jenkins.jimersylee.com_bundle.crt
│   ├── 1_jimersylee.com_bundle.crt
│   ├── 2_blog.jimersylee.com.key
│   ├── 2_jenkins.jimersylee.com.key
│   └── 2_jimersylee.com.key
└── Tomcat
    ├── jenkins.jimersylee.com.jks
    └── keystorePass.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;nginx配置
&lt;pre&gt;&lt;code&gt;
#创建配置文件
vim /etc/nginx/conf.d/jenkins.conf&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;写入以下内容&lt;/h1&gt;
&lt;h1&gt;配置443端口&lt;/h1&gt;
&lt;p&gt;server {
listen       443;
server_name  jenkins.jimersylee.com;
ssl on;
ssl_certificate /data/ssl_cert/Nginx/1_jenkins.jimersylee.com_bundle.crt;
ssl_certificate_key /data/ssl_cert/Nginx/2_jenkins.jimersylee.com.key;
ssl_session_timeout 5m;
ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置
ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置
ssl_prefer_server_ciphers on;
root /data/java_app/tomcat9/webapps;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    index index.html index.htm index.php;
    location / {
       try_files $uri @jenkins;
    }
    location @jenkins {
       internal;
       proxy_pass http://127.0.0.1:8080;
                                                      }

    access_log /data/logs/jenkins/jenkins.log main;
    }&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;转发80的访问到jenkins&lt;/h1&gt;
&lt;p&gt;server {
listen 80;
server_name jenkins.jimersylee.com;
rewrite ^ &lt;a href=&quot;https://$server_name$request_uri&quot;&gt;https://$server_name$request_uri&lt;/a&gt;? permanent;
}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 重启Nginx生效&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;nginx -s stop  #停止
nginx -t  #测试Nginx配置是否正确
nginx  #启动Nginx
```&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2017-09-04 23:02:45</pubDate>
            <link>//blog/devops/ssl.html</link>
            <guid isPermaLink="true">//blog/devops/ssl.html</guid>
                                               <category>devops</category>
                                    </item>
                <item>
            <title>我的Linux桌面环境配置与必备软件</title>
            <description>
            &lt;!--
author: Jimersy Lee
head: 
date: 2016-07-05
title: 我的Linux桌面环境配置与必备软件
tags: LINUX
images: 
category: devops
status: publish
summary: 每次装系统,都需要必备的软件,记录下来防止不时之需.
--&gt;
&lt;h1&gt;Idea&lt;/h1&gt;
&lt;p&gt;主题 Monokai_2
字体 YaHei Consolas Hybrid&lt;/p&gt;
&lt;h1&gt;phpstorm&lt;/h1&gt;
&lt;h1&gt;sublime&lt;/h1&gt;
&lt;h1&gt;jdk&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;设置环境变量
vim /etc/profile

JAVA_HOME=/opt/jdk1.8.0_141
PATH=$JAVA_HOME/bin:$PATH
CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
export JAVA_HOME
export PATH
export CLASSPATH

source  /etc/profile&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;mysql workbench&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;apt install mysql-workbench
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;maven&lt;/h1&gt;
&lt;p&gt;java包管理软件&lt;/p&gt;
&lt;h1&gt;shadowsocks,必备梯子&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;sudo apt install shadowsocks-qt5&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;tomcat&lt;/h1&gt;
&lt;h1&gt;redis-desktop-manager&lt;/h1&gt;
&lt;p&gt;redis跨平台客户端
&lt;a href=&quot;http://download.csdn.net/download/shuai825644975/9854471&quot;&gt;下载地址&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;配置lamp环境&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;安装xammp
到/opt
将bin路径加入path

vim /etc/profile

export $PTAH=$PATH:/opt/lampp/bin
这样就可以直接使用pecl来安装扩展了
pecl search redis
pecl install redis
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;nodejs npm&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;apt install  nodejs
apt install npm
设置淘宝镜像
npm config set registry https://registry.npm.taobao.org
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;编译环境组件&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;sudo apt install build-essential&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Nginx&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;编译安装nginx
下载源码
tar zxvf nginx-x.tar
cd nginx
./configure \
--prefix=/usr \
--sbin-path=/usr/sbin/nginx \
--conf-path=/etc/nginx/nginx.conf \
--error-log-path=/var/log/nginx/error.log \
--pid-path=/var/run/nginx/nginx.pid \
--user=jimersylee \
--group=jimersylee \
--with-http_ssl_module \
--with-http_flv_module \
--with-http_gzip_static_module \
--http-log-path=/var/log/nginx/access.log \
--http-client-body-temp-path=/var/tmp/nginx/client \
--http-proxy-temp-path=/var/tmp/nginx/proxy \
--http-fastcgi-temp-path=/var/tmp/nginx/fcgi \
--with-http_stub_status_module&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2017-09-12 10:01:04</pubDate>
            <link>//blog/devops/my-soft.html</link>
            <guid isPermaLink="true">//blog/devops/my-soft.html</guid>
                                               <category>devops</category>
                                    </item>
                <item>
            <title>我的后端开发书架 2015 2.0 版</title>
            <description>
            &lt;!--
author: Jimersy Lee
head: 
date: 2015-10-29
title: 我的后端开发书架 2015 2.0 版
tags: BACK-END,BOOKS
images: 
category: books
status: publish
summary: 小学生作文的开头：光阴似箭，日月如梭…..半年过去了，床底下又多了不少书，更新一个2.0版。
         自从技术书的书架设定为”床底下“之后，又多了很多买书的空间。中国什么都贵，就是书便宜。
         很多书没有全部看完，看一部分觉得值得推荐就放上来了，但在碎片化的阅读下难免错评，不定期更新修正。
         书架主要针对Java后端开发。
--&gt;
&lt;p&gt;原文出处： 江南白衣（@江南白衣Calvin)&lt;/p&gt;
&lt;p&gt;小学生作文的开头：光阴似箭，日月如梭…..半年过去了，床底下又多了不少书，更新一个2.0版。&lt;/p&gt;
&lt;p&gt;自从技术书的书架设定为”床底下“之后，又多了很多买书的空间。中国什么都贵，就是书便宜。&lt;/p&gt;
&lt;p&gt;很多书没有全部看完，看一部分觉得值得推荐就放上来了，但在碎片化的阅读下难免错评，不定期更新修正。&lt;/p&gt;
&lt;p&gt;书架主要针对Java后端开发。&lt;/p&gt;
&lt;p&gt;更偏爱那些能用简短流畅的话，把少壮不努力的程序员所需的基础补回来的薄书，而有些教课书可能很著名，但干涩枯燥，喋喋不休的把你带回到大学课堂上昏昏欲睡，不录。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;操作系统与网络的书&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;《Linux内核设计与实现 – Linux Kernel Development 第3版》
Robert Love用最薄的篇幅，顺畅的文字将Linux内核主要的算法讲清楚了，比《深入理解Linux内核》，《深入Linux内核架构》之类厚厚的全是代码的，不是专门的内核程序员看这本足够了。&lt;/p&gt;
&lt;p&gt;《Linux系统编程 第2版》
继续是Robert Love，比起APUE也是以薄见长，专门针对重要的系统调用讲解。&lt;/p&gt;
&lt;p&gt;《性能之巅》
操作系统的性能调优、监控、工具和方法论，看这本就够了，足够厚。还有本薄一点的，东抄西编格调没那么高的叫《Linux性能优化大师》。&lt;/p&gt;
&lt;p&gt;《TCP/IP详解 卷1:协议》
这么多年过去了，TCP的书好像还是只有这一本，有点旧了，看了也还是半懂不懂。后人在2011年写了第二版，看目录清晰明了与时俱进了很多，机械工业正在翻译。&lt;/p&gt;
&lt;p&gt;《现代操作系统 第3版》
如果看LKD未尽兴，可以回头看看这本基础概念，感觉比那本枯燥的《操作系统概念》(恐龙书)读起来舒服。&lt;/p&gt;
&lt;p&gt;PS. 《UNIX环境高级编程》和《UNIX网络编程》，APUE和UNP更多作为一本超厚工具书存在。《Unix 编程艺术》，扯的都是闲篇，厚厚的一本其实略读一下就行。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;算法的书&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;《数据结构与算法分析-Java语言描述 第2版》
够薄，数据结构与算法分析的点基本都涵盖了，而且示例代码还是Java写的。&lt;/p&gt;
&lt;p&gt;《算法 第4版》
可与上一本对比着读，厚一些，也多些图，但知识点没上面的全，也是Java的。&lt;/p&gt;
&lt;p&gt;《算法设计与分析基础 第3版》
数学系偏爱无比枯燥很多公式的《算法导论》， 计算机系喜欢这本实用主义的典型。翻开就看到一段很文艺很贴心的话：“效率能用数学的严密性进行精确定义，而简单性就像“美”一样，很大程度取决于审视者 的眼光。简单的算法更容易理解和实现，因而相应的程序也往往更少的Bug。当然对于简单性的美学诉求也是让人无法抗拒的。”
PS. 《数学之美》、《编程珠玑》，都是专栏文章，讲得并不系统，可以当兴趣读物来看。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;架构设计的书&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;《恰如其分的软件架构 – 风险驱动的设计方法》
由于人类与生俱来的惰性，计算机原本科学的、精准的设计方式，有了敏捷的借口之后就很难再维持了。本书就是在这种背景下，提出由风险来决定设计的度，当然，这个风险是广义的。除了开始的风险驱动部分，其余部分就是规规矩矩标标准准的架构师教科书。&lt;/p&gt;
&lt;p&gt;《软件系统架构：使用视点和视角与利益相关者合作 第2版》
也是教科书，最难得的是，这本老书在十年后的去年升级了第二版。&lt;/p&gt;
&lt;p&gt;《程序员必读之软件架构 – Software Architecture for Developers》
作者维护着codingthearchitecture.com 。不过中文书名叫“必读”有点过。薄书里的两部分内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编码的架构师：一直是我的职业模板，我记的笔记。&lt;/li&gt;
&lt;li&gt;架构的表达： 当年我觉得RUP的4+1 UML视图不足以表达系统时，Simon Brown的模板给了很好的过渡范例。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;《发布！软件的设计与部署 – Release It!: Design and Deploy Production-Ready Software 》
关于高可靠性的软件，学校里不会教，出来社会却要面对的那部分，英文的原标题更清晰。&lt;/p&gt;
&lt;p&gt;《大型网站技术架构:核心原理与案例分析》
淘宝出品，大型互联网站的科普入门书。&lt;/p&gt;
&lt;p&gt;《大规模分布式存储系统》
继续淘宝出品，分布式文件系统与数据库的科普入门书。&lt;/p&gt;
&lt;p&gt;《大数据日知录》
前几年参加各种技术会议，CAP，最终一致性，RWN，向量时钟，Paxos，一致性哈希，Gossip什么的能灌你一耳朵。而现在，你只要在家安安静静的看书就够了。不过这个领域发展太快，期望它可以持续出新版。&lt;/p&gt;
&lt;p&gt;PS. 关于设计模式，我以前曾经有过很多很多本，GOF23啦，企业应用架构模式啦，EIP啦， POSA 5卷本啦，反模式啦，JavaEE/SOA/Restful的模式啦。但现在觉得对新人来说，一本Java写的《Head First 设计模式》，知道什么叫设计模式就够了。&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;语言的书&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;《Java并发编程实战》
人手一本不用多说了。&lt;/p&gt;
&lt;p&gt;《深入理解 Java 虚拟机 第2版》
深入理解虚拟机并不是那么难，Java程序员都该看看，很多知识其实是必须的。另外还有几本类似主题的，忽然一下子都出来了。&lt;/p&gt;
&lt;p&gt;《Java性能优化权威指南》
虽然后面的章节好像用处不大，前面有些部分还是值得看，不过Gosling说圣经有点过了。&lt;/p&gt;
&lt;p&gt;《写给大忙人看的Java SE 8》
事实上，为了保持兼容性，很多项目还保持在JDK5/6上，这本书一次过将JDK7/JDK8的更新讲了，虽然讲得还不全。&lt;/p&gt;
&lt;p&gt;《函数式编程思维》
Java8终于有函数式的影子了，不要落后太多，开始尝试跟上节奏。这本书是TW的Neal Ford面向Java程序员写的薄书。&lt;/p&gt;
&lt;p&gt;《七周七语言》
《七周七X》系列的开山之作，可能也是最好的一本。&lt;/p&gt;
&lt;p&gt;PS. 《Effective Java》外界一致推崇，但有点太过誉了。另外《Thinking in Java》有点旧了，而且作者思路随意，译者语言晦涩，新程序员还是建议同时再看两卷《Java核心技术 － Core Java》。&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;具体技术的书&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;《Docker: 容器与容器云》
这本书叫Docker一本就够了，的确够了，在那些Docker操作指南书之上，不想着改Docker代码的看它就够了，别想着什么《Docker源码分析》。&lt;/p&gt;
&lt;p&gt;《Redis设计与实现》
用Redis的工程师桌面必备吧，不用再多说了。&lt;/p&gt;
&lt;p&gt;《从Paxos到Zookeeper》
Zookeeper的书，淘宝出品。&lt;/p&gt;
&lt;p&gt;《Spark技术内幕》
深度与厚度之间，选了这本200页的薄书，一样有很多的原理与代码解释，但不会像有的书那样贴20行代码只写一行字。&lt;/p&gt;
&lt;p&gt;《Netty权威指南 第2版》
虽然网上的吐槽较多，但Netty 快速入门也只有这一本了。&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;程序员的自我修养&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;PS. 最近没买什么新书，随便说点旧书:&lt;/p&gt;
&lt;p&gt;《程序员修炼之道-从小工到专家》，Pragmatic Programmer-注重实效的程序员开山之作，翻译的马达维文笔也和熊节一样好。&lt;/p&gt;
&lt;p&gt;《代码整洁之道》和 《程序员的职业素养》，英文名是很相近的《Clean Code》和 《Clean Coder》，应该接替《代码大全2》成为必看的系列，因为后者太厚了，而且也有不少过时的东西，要自己去过滤。&lt;/p&gt;
&lt;p&gt;《重构》很厚，但最有价值就是前面几章的洗脑篇，具体实作不如薄薄的《重构手册》。&lt;/p&gt;
&lt;p&gt;关于敏捷的书，最开始的那本《解析极限编程–拥抱变化》就很好，再随便找本Scrum的流程看看就够了，《敏捷开发的艺术》也不错。&lt;/p&gt;
&lt;p&gt;《布道之道 – Driving Technical Change:Why People on Your Team Don’t Act on Good Ideas,and How to Convince Them They Should》，经常在组织里推行新技术的同学可以看下，七种怀疑论者模式，脑海中一幅幅熟悉的面孔。&lt;/p&gt;
&lt;p&gt;PS. 温伯格的书网上很推崇，《成为技术领导者》之类的，但我觉得年代太远，读起来其实没多大意思，一两个鸡汤观点还要自己从书里慢慢淘，有那功夫不如看点别的。&lt;/p&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;没有覆盖到的内容&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数据库如MySQL，我们DBA太专业，自己没机会搞。&lt;/p&gt;
&lt;p&gt;欢迎大家在评论里补充。&lt;/p&gt;            </description>
            <pubDate>2017-09-12 10:01:04</pubDate>
            <link>//blog/books/back-end-books-2015.html</link>
            <guid isPermaLink="true">//blog/books/back-end-books-2015.html</guid>
                                               <category>books</category>
                                    </item>
                <item>
            <title>机器学习和数据挖掘的推荐书单</title>
            <description>
            &lt;!--
author: Jimersy Lee
head: 
date: 2015-10-26
title: 机器学习和数据挖掘的推荐书单
tags: ML,BOOKS
images: 
category: books
status: publish
summary: 有了这些书，再也不愁下了班没妹纸该咋办了。慢慢来，认真学，揭开机器学习和数据挖掘这一神秘的面纱吧！
--&gt;
&lt;p&gt;本文作者： 伯乐在线 - 天才白痴梦 。&lt;/p&gt;
&lt;p&gt;有了这些书，再也不愁下了班没妹纸该咋办了。慢慢来，认真学，揭开机器学习和数据挖掘这一神秘的面纱吧！&lt;/p&gt;
&lt;p&gt;《机器学习实战》： 本书第一部分主要介绍机器学习基础，以及如何利用算法进行分类，并逐步介绍了多种经典的监督学习算法，如k近邻算法、朴素贝叶斯算法、Logistic回 归算法、支持向量机、AdaBoost集成方法、基于树的回归算法和分类回归树（CART）算法等。第三部分则重点介绍无监督学习及其一些主要算法：k均 值聚类算法、Apriori算法、FP-Growth算法。第四部分介绍了机器学习算法的一些附属工具。&lt;/p&gt;
&lt;p&gt;全书通过精心编排的实例，切入日常工作任务，摒弃学术化语言，利用高效的可复用Python代码来阐释如何处理统计数据，进行数据分析及可视化。通 过各种实例，读者可从中学会机器学习的核心算法，并能将其运用于一些策略性任务中，如分类、预测、推荐。另外，还可用它们来实现一些更高级的功能，如汇总 和简化等。&lt;/p&gt;
&lt;p&gt;之前看过一部分这本书，但是实习工作涉及到用Java代码处理数据，所以暂时先搁一下，目前正在李航的那本书。&lt;/p&gt;
&lt;p&gt;《数据挖掘-实用机器学习技术》： 本书介绍数据挖掘的基本理论与实践方法。主要内容包括：各种模型(决策树，关联规则、线性模型、聚类、贝叶斯网以及神经网络)以及在实践中的运用，所存任 缺陷的分析。安全地清理数据集、建立以及评估模型的预测质量的方法，并且提供了一个公开的数据挖掘工作平台Weka。Weka系统拥有进行数据挖掘仟务的 图形用户界面，有助于理解模型，是一个实用并且深受欢迎的工具。&lt;/p&gt;
&lt;p&gt;《数据挖掘：概念与技术》： 本书全面地讲述数据挖掘领域的重要知识和技术创新。在第1版内容相当全面的基础上，第2版展示了该领域的最新研究成果，例如挖掘流、时序和序列数据以及挖 掘时间空间、多媒体、文本和Web数据。本书可作为数据挖掘和知识发现领域的教师、研究人员和开发人员的一本必读书。&lt;/p&gt;
&lt;p&gt;《统计学习基础 数据挖掘、推理与预测》：尽管应用的是统计学方法，但强调的是概念，而不是数学。许多例子附以彩图。《统计学习基础:数据挖掘、推 理与预测》内容广泛，从有指导的学习（预测）到无指导的学习，应有尽有。包括神经网络、支持向量机、分类树和提升等主题，是同类书籍中介绍得最全面的。计 算和信息技术的飞速发展带来了医学、生物学、财经和营销等诸多领域的海量数据。理解这些数据是一种挑战，这导致了统计学领域新工具的发展，并延伸到诸如数 据挖掘、机器学习和生物信息学等新领域。&lt;/p&gt;
&lt;p&gt;《机器学习》 （Mitchell）：展示了机器学习中核心的算法和理论，并阐明了算法的运行过程。《机器学习》综合了许多的研究成果，例如统计学、人工智能、哲学、信 息论、生物学、认知科学、计算复杂性和控制论等，并以此来理解问题的背景、算法和其中的隐含假定。《机器学习》可作为计算机专业 本科生、研究生教材，也 可作为相关领域研究人员、教师的参考书。&lt;/p&gt;
&lt;p&gt;《统计学习方法》： 本书全面系统地介绍了统计学习的主要方法，特别是监督学习方法，包括感知机、k近邻法、朴素贝叶斯法、决策树、逻辑斯谛回归与最大熵模型、支持向量机、提 升方法、em算法、隐马尔可夫模型和条件随机场等。除第1章概论和最后一章总结外，每章介绍一种方法。叙述从具体问题或实例入手，由浅入深，阐明思路，给 出必要的数学推导，便于读者掌握统计学习方法的实质，学会运用。为满足读者进一步学习的需要，书中还介绍了一些相关研究，给出了少量习题，列出了主要参考 文献。&lt;/p&gt;
&lt;p&gt;《机器学习导论》：对机器学习的定义和应用实例进行了介绍，涵盖了监督学习。贝叶斯决策理论。参数方法、多元方法、维度归约、聚类、非参数方法、决策树。线性判别式、多层感知器，局部模型、隐马尔可夫模型。分类算法评估和比较，组合多学习器以及增强学习等。&lt;/p&gt;
&lt;p&gt;《机器学习及其应用》：全书共分14章，内容分别涉及因果推断、流形学习与降维、迁移学习、类别不平衡学习、演化聚类、多标记学习、排序学习、半监督学习等技术和协同过滤、社区推荐、机器翻译等应用，以及互联网应用对机器学习技术需求的探讨。&lt;/p&gt;
&lt;p&gt;《模式分类》第二版：除了保留了第1版的关于统计模式识别和结构模式识别的主要内容以外，读者将会发现新增了许多近25年来的新理论和新方法，其中包括神经网络、机器学习、数据挖掘、进化计算、不变量理论、隐马尔可夫模型、统计学习理论和支持向量机等。&lt;/p&gt;
&lt;p&gt;《推荐系统实践》：过大量代码和图表全面系统地阐述了和推荐系统有关的理论基础，介绍了评价推荐系统优劣的各种标准(比如覆盖率、满意度)和方法(比如AB测试)，总结了当今互联网领域中各种和推荐有关的产品和服务。&lt;/p&gt;
&lt;p&gt;《深入搜索引擎：海量信息的压缩、索引和查询》：理论和实践并重，深入浅出地给出了海量信息数据处理的整套解决方案，包括压缩、索引和查询的方方面面。其最大的特色在于不仅仅满足信息检索理论学习的需要，更重要的是给出了实践中可能面对的各种问题及其解决方法。&lt;/p&gt;
&lt;p&gt;《概率论与数理统计》：这本书不用过多介绍了吧，普遍大学里大一时期的教科书，只恨当年没听课啊，现在正在慢慢啃。。。&lt;/p&gt;
&lt;p&gt;《大数据：互联网大规模数据挖掘与分布式处理》：主要内容包括分布式文件系统、相似性搜索、搜索引擎技术、频繁项集挖掘、聚类算法、广告管理及推荐系统。&lt;/p&gt;
&lt;p&gt;《Web数据挖掘》： 信息检索领域的书籍，该书深入讲解了从大量非结构化Web数据中提取和产生知识的技术。书中首先论述了Web的基础（包括Web信息采集机制、Web标引 机制以及基于关键字或基于相似性搜索机制），然后系统地描述了Web挖掘的基础知识，着重介绍基于超文本的机器学习和数据挖掘方法，如聚类、协同过滤、监 督学习、半监督学习，最后讲述了这些基本原理在Web挖掘中的应用。《Web数据挖掘》为读者提供了坚实的技术背景和最新的知识。&lt;/p&gt;
&lt;p&gt;《数据之巅》：对大数据追根溯源，提出当前信息技术的发展，已经让中国获得了后发优势，中国要在大数据时代的全球竞争中胜出，必须把大数据从科技符号提升成为文化符号，在全社会倡导数据文化。&lt;/p&gt;
&lt;p&gt;《深入浅出统计学》：本书涵盖的知识点包括：信息可视化、概率计算、几何分布、二项分布及泊松分布、正态分布、统计抽样、置信区间的构建、假设检验、卡方分布、相关与回归等等，完整涵盖AP考试范围。&lt;/p&gt;
&lt;p&gt;《矩阵分析》： 本书从数学分析的角度论述矩阵分析的经典方法和现代方法，取材新，有一定的深度，并给出在多元微积分、复分析、微分方程、量优化、逼近理论中的许多重要应 用。主要内容包括：特征值、特征向量和相似性，酉等价和正规矩阵，标准形，Hermite矩阵和对称矩阵，向量范数和矩阵范数，特征值和估计和扰动，正定 矩阵，非负矩阵。&lt;/p&gt;            </description>
            <pubDate>2017-09-12 10:01:04</pubDate>
            <link>//blog/books/ML-books.html</link>
            <guid isPermaLink="true">//blog/books/ML-books.html</guid>
                                               <category>books</category>
                                    </item>
                <item>
            <title>JS规则-使用js的最佳实践</title>
            <description>
            &lt;!--
author: Jimersy Lee
head: 
date: 2015-10-13
title: JS规则-使用js的最佳实践
tags: JS,JAVASCRIPT
images: 
category: js
status: publish
summary: 本文列出了使用js的12条军规
--&gt;
&lt;h1&gt;1. JS应该放到 .js 文件中&lt;/h1&gt;
&lt;p&gt;“额，只有那么几行而已…”，是的，我的意思是所有的 JS 都应该放在.js文件中。为什么呢？因为这有助于可读性，节省带宽。行内 JavaScript 在每次页面加载时都会重新下载，相反的，单独的.js文件则会被缓存起来。正如你所看到的，这个规则有助于支持如下一长串的其他规则。这就是为什么它的规则# 1。&lt;/p&gt;
&lt;h1&gt;2. JS 应该是静态的&lt;/h1&gt;
&lt;p&gt;我看到过很多程序员喜欢动态的使用JavaScript。他们喜欢像使用服务器端语言如C#, Ruby, Java那样来动态的使用JavaScript。千万不要这么做。你失去了代码着色、语法高亮显示和智能感知的支持。记住，JavaScript 应该属于一个.js文件(见规则 #1)。&lt;/p&gt;
&lt;p&gt;然而，使用JSON引入动态行为。我把这称为JavaScript配置对象模式。具体方法如下：把JSON注入到你应用程序的头部，并根据业务逻辑 的需要利用这些数据。你可能会想：“嘿，这违背了规则 #1”。我把 JSON 看作是数据，而不是代码，所以我破例，为了支持静态的、单独的JavaScript文件。&lt;/p&gt;
&lt;p&gt;StackOverflow 使用的这种模式，Google 也是。&lt;/p&gt;
&lt;h1&gt;3. JS 应该被压缩&lt;/h1&gt;
&lt;p&gt;压缩可以减小文件体积，从而提升页面加载速度。记住，性能也是一项功能。因为，为了压缩，你需要把 JS 放到一个单独的文件中(见规则 #1)。压缩JS曾经很麻烦，但现在完全是简单自动化的。有一打的方式可以做到，而Gulp和gulp-uglify是一种低摩擦和自动化的办法。&lt;/p&gt;
&lt;h1&gt;4. JS 应该位于页面底部&lt;/h1&gt;
&lt;p&gt;如果你把&amp;lt;script&gt;标签放在&amp;lt;head&gt;中，它会阻碍页面渲染。位于&amp;lt;head&gt;中的脚本必须在页面显示前加载，因此把&amp;lt;script&gt;放在底部的 &lt;/body&gt; 前面可以先显示页面，而不用等 JS 文件下载完毕。这有助于提升感知性能。如果你的JavaSctipe必须位于&amp;lt;head&gt;中，可以考虑使用 jQuery 的$(document).ready这样你的脚本可以等到 DOM 加载完毕后再执行。&lt;/p&gt;
&lt;h1&gt;5. JS 应该实时的 Linted&lt;/h1&gt;
&lt;p&gt;Linting 遵循代码风格、发现错别字、有助于避免错误。有很多这样的工具，我建议使用ESLint。你可以使用 Gulp 的gulp-eslint来运行它。Gulp 可以查看你所有的 JS 文件，并在你每次保存的时候运行 linter。另外，你需要把你的 JS 代码放在单独的 .js 文件中才能运行 linter 。&lt;/p&gt;
&lt;h1&gt;6.JS应该有自动化测试&lt;/h1&gt;
&lt;p&gt;在过去的几年中，我们知道了测试的重要性。但它在很大程度上忽略了在JavaScript，直到最近才被重视。现在典型的JavaScript应用需要测试的部分远比你实际手动测试到的要多。使用JavaScript处理这么多的逻辑，关键的是具有自动测试。&lt;/p&gt;
&lt;p&gt;您可以通过工具，如Selenium自动化集成测试。然而，集成测试往往是脆弱的，所以我建议专注于自动化单元测试。自动化单元测试有多种选择。如果你是新手， 我建议你使用Jasmine，而如果你想要终极配置，可以使用MochawithChai。&lt;/p&gt;
&lt;h1&gt;7. JS 需要封装&lt;/h1&gt;
&lt;p&gt;前些年我们了解了全局变量的风险，值得庆幸的是，现在有很多的方法来封装JS：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Immediately Invoked Function Expressions(aka IIFE)&lt;/li&gt;
&lt;li&gt;Revealing Modules&lt;/li&gt;
&lt;li&gt;AMD(typically viaRequireJS)&lt;/li&gt;
&lt;li&gt;CommonJS(used byNode.js, use in browser viaBrowserifyorWebpack)&lt;/li&gt;
&lt;li&gt;ES6 modules&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ES6模块是未来。好消息是，虽然在浏览器中还不能很好的支持，但你可以用Babel来使用它。&lt;/p&gt;
&lt;p&gt;如果你不想transpile，CommonJS可能是你最佳的选择。由于 Node 使用的CommonJS 模式，所以你可以使用npm来下载数千个包。CommonJS 不能在浏览器中运行，所以你可能需要Browserify，Webpack, orJSPM.&lt;/p&gt;
&lt;h1&gt;8. JS 依赖应当明确&lt;/h1&gt;
&lt;p&gt;这条规则与上述规则紧密相关。一旦你开始封装JavaScript，您需要一个简单的方法来引用其他模块。这就是常说的现代模块系统CommonJS和ES6模块的好处。你只需要在文件顶部指定依赖，就像Java 或 C# 那样一句声明：&lt;/p&gt;
&lt;p&gt;//CommonJS
var react = require('react');
//ES6 Modules
import React from 'React'&lt;/p&gt;
&lt;h1&gt;9.Transpile to JS&lt;/h1&gt;
&lt;p&gt;最新版本的JavaScript，EcmaScript 2015(被大家熟知的名字是ES6) 官方版本在 6月份发布了。浏览器还不能很好的支持它的很多特性，但这并无关紧要。你可以用Babel来体验它的新特性。Babel 把 ES6 transpile 到 ES5，如果你能忍受这么做，你现在就可以享受 ES6 的新特性。JavaScript预计一年发布一次的新版本了，所以你可能一直需要transpiling 。&lt;/p&gt;
&lt;p&gt;或者你喜欢强类型？那么你可以考虑TypeScript。&lt;/p&gt;
&lt;h1&gt;10.JS应该自动构建&lt;/h1&gt;
&lt;p&gt;我们已经谈到了linting、压缩、transpilation 和测试。但如何才能让这一切自动发生？很简单：使用自动构建。Gulp 就是这样一个结合了所有功能的工具。不过你也可以选择Grunt和Webpack。或者如果你是一个高手，你也可以使用npm 来构建。问题的关键是，不要指望人记得手动运行这些东西的，自动化是一个非常棒的选择。&lt;/p&gt;
&lt;h1&gt;11. 使用框架或者库&lt;/h1&gt;
&lt;p&gt;拿一些现成的东西来用。想保持轻量级？试试Backbone或Knockout。或者jQuery就够了。想要更多更全功能的？试试Angular，Ember,，或者ReactwithFlux。&lt;/p&gt;
&lt;p&gt;关键是：&lt;/p&gt;
&lt;p&gt;不要试图从头开始。站在巨人的肩膀上。&lt;/p&gt;
&lt;p&gt;不管你选择哪个框架，都应该分开你的关注，这就是下一点..&lt;/p&gt;
&lt;h1&gt;12. JS Should Separate Concerns&lt;/h1&gt;
&lt;p&gt;把 JS代码放到一个文件中的习惯很容易养成，或者盲目跟从你的框架的意见。当你移动到客户端的时候，不要忘记你在服务器端学到的经验教训。&lt;/p&gt;
&lt;p&gt;这里并不仅仅意味着就像你在Angular 和 Knockout等 MVC 框架中那样分离模型、视图、控制器。编写JavaScript的时候应该像服务器端开发者那样思考问题。把你的业务逻辑和数据访问分离出来。&lt;/p&gt;
&lt;p&gt;这意味着AJAX调用都应该在一个地方。创建一个集中的客户端“数据访问层”。业务逻辑模块应包含纯JavaScript的。这使得逻辑易于重用，易于测试，升级也不受影响。&lt;/p&gt;            </description>
            <pubDate>2017-09-12 10:01:04</pubDate>
            <link>//blog/js/JS-rule.html</link>
            <guid isPermaLink="true">//blog/js/JS-rule.html</guid>
                                               <category>js</category>
                                    </item>
                <item>
            <title>使用scrapy写爬虫</title>
            <description>
            &lt;!--
author: Jimersy Lee
head: 
date: 2015-08-04
title: 使用scrapy写爬虫
tags: PYTHON,SCRAPY,CRAWLER
images: 
category: python
status: publish
summary: 学习使用python的scrapy写爬虫
--&gt;
&lt;p&gt;一开始想在windows环境下安装scrapy,无奈安装多次都失败,转向linux&lt;/p&gt;
&lt;p&gt;linux自带python2.7 因此只需要安装scrapy模块就行&lt;/p&gt;
&lt;p&gt;先用pip安装Scrapy 失败&lt;/p&gt;
&lt;p&gt;于是安装easy_install&lt;/p&gt;
&lt;p&gt;命令行 sudo apt-get install python-setuptools&lt;/p&gt;
&lt;p&gt;sudo easy_install Scrapy&lt;/p&gt;
&lt;p&gt;出现错误,搜索知道必须使用python的dev版本&lt;/p&gt;
&lt;p&gt;于是  sudo apt-get install python-dev&lt;/p&gt;
&lt;p&gt;再次 sudo easy_install Scrapy&lt;/p&gt;
&lt;p&gt;安装成功&lt;/p&gt;
&lt;p&gt;然后安装mongodb&lt;/p&gt;
&lt;p&gt;sudo easy_instal pymongo&lt;/p&gt;            </description>
            <pubDate>2017-09-08 04:02:34</pubDate>
            <link>//blog/python/scrapy.html</link>
            <guid isPermaLink="true">//blog/python/scrapy.html</guid>
                                               <category>python</category>
                                    </item>
                <item>
            <title>spacevim安装与使用</title>
            <description>
            &lt;!--
author: Jimersy Lee
head: 
date: 2015-08-03
title: spacevim安装与使用
tags: VIM,SPACEVIM
images: 
category: 
status: publish
summary: 学习使用vim的一个扩展项目,spacevim,打造更好的vim编程环境
--&gt;
&lt;h1&gt;安装&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;安装spacevim的前提是安装好vim,一般linux系统自带&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#redhat系列
sudo yum install vim / sudo dnf install vim
#debian系列
sudo apt install vim 
#或者
sudo apt-get install vim 
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装spacevim&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -sLf https://spacevim.org/install.sh | bash&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;启动spacevim,等待下载插件
&lt;pre&gt;&lt;code&gt;vim test.txt&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;使用&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;```
#打开目录 
vim path
#右边就会出现目录,移动光标到目录上,按回车键,就能进入目录;移动到文件上,按回车键就能打开文件;按退格键能返回上级目录
#切换工程目录区与编辑的文件
&amp;lt;ctrl+tab&amp;gt;
#创建文件
在工程区移动到文件夹下,按&amp;lt;shift+n&amp;gt;,下方提示栏就会出现提示,输入文件名,回车,创建文件
#删除文件
在工程区移动到文件夹下,按&amp;lt;dd&amp;gt;,下方提示栏就会出现提示,是否要删除,输入yes删除
```&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2017-09-12 10:01:04</pubDate>
            <link>//blog/vim/spacevim.html</link>
            <guid isPermaLink="true">//blog/vim/spacevim.html</guid>
                    </item>
                <item>
            <title>PHP字符串常用函数学习</title>
            <description>
            &lt;!--
author: Jimersy Lee
head: 
date: 2015-07-09
title: PHP字符串常用函数学习
tags: PHP,STRING
images: 
category: php
status: publish
summary: 包括字符串的常用操作
--&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;/html&amp;gt;
&amp;lt;?php

echo '1 int crc32(string str),产生32位长的crc多项式,比如crc32(&quot;helllo&quot;)&amp;lt;br/&amp;gt;';
echo crc32 (&quot;jkkajjjk\n&quot;);
echo '&amp;lt;br/&amp;gt;';

echo '2 string bin2hex(string str) , 把二进制转换为十六进制,比如bin2hex(&quot;helloworld&quot;)&amp;lt;br/&amp;gt;';
echo bin2hex(&quot;hello world&quot;);
echo '&amp;lt;br/&amp;gt;';

echo '3 string chop(string str),移除str后面多余的空白,返回新的字符串&amp;lt;br/&amp;gt;';
echo 'kkkj l ';
echo 'hahah';
echo chop(&quot;kkkj l &quot;);
echo 'hahah';
echo '&amp;lt;br/&amp;gt;';

echo '4 string chr(int ascii),返回指定ascii码表示的字符,如chr(100)&amp;lt;br/&amp;gt;';
echo chr(100);
echo '&amp;lt;br/&amp;gt;';
echo '5 int ord(string str),返回str字符串第一个字符的ascii码,如ord(&quot;d&quot;),&amp;lt;br/&amp;gt;';
echo ord(&quot;d&quot;);
echo &quot;&amp;lt;br/&amp;gt;&quot;;
echo '6 string chunk_split(string str,int chunklen, string end),把字符串没隔一定数目就分割,如chunk_split(&quot;jasdjkasjdkasadas&quot;,5,&quot;|&quot;),就是把字符串每5个字符用|分割&amp;lt;br/&amp;gt;';
echo chunk_split(&quot;jasdjkasjdkasadas&quot;,5,&quot;|&quot;);
echo '&amp;lt;br/&amp;gt;';
echo '7 string crypt(string str,string salt),单向加密,无解密函数~';
echo '&amp;lt;br/&amp;gt;';
echo crypt(&quot;hello world&quot;,&quot;kk&quot;);
echo '&amp;lt;br/&amp;gt;';
echo '
CRYPT_STD_DES - 基于标准 DES 算法的散列使用 &quot;./0-9A-Za-z&quot; 字符中的两个字符作为盐值。在盐值中使用非法的字符将导致 crypt() 失败。
CRYPT_EXT_DES - 扩展的基于 DES 算法的散列。其盐值为 9 个字符的字符串，由 1 个下划线后面跟着 4 字节循环次数和 4 字节盐值组成。它们被编码成可打印字符，每个字符 6 位，有效位最少的优先。0 到 63 被编码为 &quot;./0-9A-Za-z&quot;。在盐值中使用非法的字符将导致 crypt() 失败。
CRYPT_MD5 - MD5 散列使用一个以 $1$ 开始的 12 字符的字符串盐值。
CRYPT_BLOWFISH - Blowfish 算法使用如下盐值：“$2a$”，一个两位 cost 参数，“$” 以及 64 位由 “./0-9A-Za-z” 中的字符组合而成的字符串。在盐值中使用此范围之外的字符将导致 crypt() 返回一个空字符串。两位 cost 参数是循环次数以 2 为底的对数，它的范围是 04-31，超出这个范围将导致 crypt() 失败。
CRYPT_SHA256 - SHA-256 算法使用一个以 $5$ 开头的 16 字符字符串盐值进行散列。如果盐值字符串以 “rounds=&amp;lt;N&amp;gt;$” 开头，N 的数字值将被用来指定散列循环的执行次数，这点很像 Blowfish 算法的 cost 参数。默认的循环次数是 5000，最小是 1000，最大是 999,999,999。超出这个范围的 N 将会被转换为最接近的值。
CRYPT_SHA512 - SHA-512 算法使用一个以 $6$ 开头的 16 字符字符串盐值进行散列。如果盐值字符串以 “rounds=&amp;lt;N&amp;gt;$” 开头，N 的数字值将被用来指定散列循环的执行次数，这点很像 Blowfish 算法的 cost 参数。默认的循环次数是 5000，最小是 1000，最大是 999,999,999。超出这个范围的 N 将会被转换为最接近的值。

';

if (CRYPT_STD_DES == 1)
{
echo &quot;Standard DES: &quot;.crypt(&quot;hello world&quot;).&quot;\n&amp;lt;br /&amp;gt;&quot;;
}
else
{
echo &quot;Standard DES not supported.\n&amp;lt;br /&amp;gt;&quot;;
}

if (CRYPT_EXT_DES == 1)
{
echo &quot;Extended DES: &quot;.crypt(&quot;hello world&quot;).&quot;\n&amp;lt;br /&amp;gt;&quot;;
}
else
{
echo &quot;Extended DES not supported.\n&amp;lt;br /&amp;gt;&quot;;
}

if (CRYPT_MD5 == 1)
{
echo &quot;MD5: &quot;.crypt(&quot;hello world&quot;).&quot;\n&amp;lt;br /&amp;gt;&quot;;
}
else
{
echo &quot;MD5 not supported.\n&amp;lt;br /&amp;gt;&quot;;
}

if (CRYPT_BLOWFISH == 1)
{
echo &quot;Blowfish: &quot;.crypt(&quot;hello world&quot;);
}
else
{
echo &quot;Blowfish DES not supported.&quot;;
}

echo '&amp;lt;br/&amp;gt;';

echo ' 8 array explode (string separator, string string [, int limit]),传回一个字符串的数组，以参数 separator为界线将参数 string切开，如果有设定参数 limit，则传回的数组最多将会包含 limit个元素，而最后一个元素将会包含 string全部剩余的部份。&amp;lt;br/&amp;gt;';
$pizza=&quot;haa kkkk kllom lljjijj iioo &quot;;
$pieces=explode(&quot; &quot;,$pizza);
foreach($pieces as $val){
echo $val;

}
echo '&amp;lt;br/&amp;gt;';

echo '9 string implode (string glue, array pieces) 以参数glue将数组pieces的各个元素结合起来成字符串返回.与join(string glue,array pieces)相同用法&amp;lt;br/&amp;gt;';

echo implode (&quot;:&quot;, $pieces);
echo '&amp;lt;br/&amp;gt;';

echo '10 array split (string pattern, string string [, int limit]),以正则把字符串切开 '

?&amp;gt;&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2017-09-08 04:02:34</pubDate>
            <link>//blog/php/php-string.html</link>
            <guid isPermaLink="true">//blog/php/php-string.html</guid>
                                               <category>php</category>
                                    </item>
                <item>
            <title>设计模式之观察者模式</title>
            <description>
            &lt;!--
author: Jimersy Lee
head: 
date: 2015-04-08
title: 设计模式之观察者模式
tags: JAVA,PATTERN
images: 
category: 
status: publish
summary: 观察者模式(Observer),让你的对象知悉现况
--&gt;
&lt;h1&gt;观察者模式(Observer)&lt;/h1&gt;
&lt;p&gt;让你的对象知悉现况&lt;/p&gt;
&lt;p&gt;使用自定义的Subject(主题)与Observer(观察者模式)&lt;/p&gt;
&lt;p&gt;设计原则&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;找出程序中会变化的方面,然后将其和固定不变的部分分离&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在观察者模式中,会改变的事主题的状态,以及观察者的数目和类型.用这个模式,你可以改变依赖于主题状态的对象,却不改变主题.这就叫提前规划&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;针对接口编程,不针对实现编程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主题与观察者都使用接口:观察者利用主题的接口向主题注册,二主题利用观察者接口通知观察者.这样可以让两者之前运作正常,同时具有松耦合的优点&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;多用组合,少用继承&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;观察者模式利用&amp;quot;组合&amp;quot;将许多观察者组合进主题中.对象之前的这种关系不是通过继承产生的,而是在运行时利用组合的方式而产生的.&lt;/p&gt;
&lt;h1&gt;自己实现观察者模式&lt;/h1&gt;
&lt;h2&gt;我们先定义主题接口&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;
/**
 * 主题接口
 */
public interface Subject {
    public void registerObserver(Observer o);
    public void removeObserver(Observer o);
    public void notifyObservers();

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;定义观察者接口&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 观察者接口
 */
public interface Observer {
    public void update(float temp,float humidity,float pressure);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;显示元素接口&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 显示元素接口
 */
public interface DisplayElement {
    public void display();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;编写公告板实现,实现了观察者接口与显示元素接口&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 公告板实现
 */
public class CurrentConditionDisplay implements Observer,DisplayElement {
    private float temperature;
    private float humidity;
    private Subject weatherData;

    /**
     * 构造器需要weatherData对象(也就是主题)作为注册之用
     * @param weatherData:天气对象
     */
    public CurrentConditionDisplay(Subject weatherData){
        this.weatherData=weatherData;
        weatherData.registerObserver(this);
    }

    /**
     * display()方法就只是把最近的问的和湿度显示出来
     */
    @Override
    public void display() {
        System.out.println(&quot;Current conditions:&quot;+temperature+&quot;F degree and &quot;+humidity+&quot;% humidity&quot;);
    }

    /**
     * 当update被调用时,我们把温度和湿度保存起来,然后调用display
     * @param temp
     * @param humidity
     * @param pressure
     */
    @Override
    public void update(float temp, float humidity, float pressure) {
            this.temperature=temp;
            this.humidity=humidity;
            display();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;天气数据实现主题接口&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import java.util.ArrayList;

/**
 * 天气数据类实现了Subject(主题)接口
 */
public class WeatherData implements Subject {
    private ArrayList&amp;lt;Observer&amp;gt; observers;
    private float temperature;
    private float humidity;
    private float pressure;

    public WeatherData(){
        observers=new ArrayList&amp;lt;&amp;gt;();
    }

    @Override
    public void registerObserver(Observer o) {
        observers.add(o);
    }

    @Override
    public void removeObserver(Observer o) {
        int i=observers.indexOf(o);
        if(i&amp;gt;=0){
            observers.remove(i);
        }
    }

    @Override
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(temperature, humidity, pressure);
        }
    }

    /**
     * 此方法会在气象值变化时被调用
     */
    public void measurementsChanged(){
        notifyObservers();
    }

    public void setMeasurements(float temperature,float humidity,float pressure){
        this.temperature=temperature;
        this.humidity=humidity;
        this.pressure=pressure;
        measurementsChanged();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;来个测试吧&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;public class WeatherStation {
    public static void main(String[] args){
        WeatherData weatherData=new WeatherData();

        CurrentConditionDisplay currentConditionDisplay=new CurrentConditionDisplay(weatherData);
        weatherData.setMeasurements(80,65,30.4f);
    }
}

#输出
Current conditions:80.0F degree and 65.0% humidity&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;使用java自带的Observer&lt;/h1&gt;
&lt;h2&gt;定义显示元素接口&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;package Observable;

public interface DisplayElement {
    public void display();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;实现观察者接口和显示元素接口&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;package Observable;

import java.util.Observable;
import java.util.Observer;

/**
 * 天气状况布告板
 * Created by jimersylee on 
 */
public class CurrentConditionDisplay implements Observer,DisplayElement {
    Observable observable;
    private float temperature;
    private float humidity;

    public CurrentConditionDisplay(Observable observable){
        this.observable=observable;
        observable.addObserver(this);
    }

    public void update(Observable obs,Object arg){
        if(obs instanceof WeatherData){
            WeatherData weatherData=(WeatherData)obs;
            this.temperature=weatherData.getTemperature();
            this.humidity=weatherData.getHumidity();
            display();
        }
    }

    public void display(){
        System.out.println(&quot;Current conditions:&quot;+temperature+&quot;F degrees and &quot;+humidity+&quot;% humidity&quot;);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;实现观察者抽象类&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;package Observable;

import java.util.Observable;

/**
 * 使用java.util内置的观察者模式实现
 * Created by jimersylee 
 */
public class WeatherData extends Observable {
    private float temperature;
    private float humidity;
    private float pressure;

    public WeatherData(){

    }

    public void measurementsChanged(){
        setChanged();
        notifyObservers();
    }

    public float getTemperature(){
        return temperature;
    }

    public float getHumidity(){
        return humidity;
    }

    public float getPressure(){
        return pressure;
    }

    public void setMeasurements(float temperature,float humidity,float pressure){
        this.temperature=temperature;
        this.humidity=humidity;
        this.pressure=pressure;
        measurementsChanged();
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;写个测试吧&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;package Observable;

public class WeatherStation {
    public static void main(String[] args){
        WeatherData weatherData=new WeatherData();

        CurrentConditionDisplay currentConditionDisplay=new CurrentConditionDisplay(weatherData);

        weatherData.setMeasurements(80,30,33.2f);
    }
}

#输出
Current conditions:80.0F degrees and 30.0% humidity
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;项目地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jimersylee/DesignPattern&quot;&gt;java设计模式实现&lt;/a&gt;
如果觉得有点收获,记得在项目上点star哦!&lt;/p&gt;            </description>
            <pubDate>2017-09-12 10:01:04</pubDate>
            <link>//blog/java/design-pattern-observer.html</link>
            <guid isPermaLink="true">//blog/java/design-pattern-observer.html</guid>
                    </item>
                <item>
            <title>设计模式之面向接口</title>
            <description>
            &lt;!--
author: Jimersy Lee
head: 
date: 2015-03-14
title: 设计模式之面向接口
tags: JAVA,PATTERN
images: 
category: java
status: publish
summary: 不变的就是变化,驱动改变的因素很多.找出你的应用中需要改变代码的原因.1. 用户需要新的功能 2. 需要推出新的活动 3. 应用改版 4. 为了更好的性能
--&gt;
&lt;h1&gt;软件开发的一个不变真理&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;不变的就是变化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;驱动改变的因素很多.找出你的应用中需要改变代码的原因&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户需要新的功能&lt;/li&gt;
&lt;li&gt;需要推出新的活动&lt;/li&gt;
&lt;li&gt;应用改版&lt;/li&gt;
&lt;li&gt;为了更好的性能&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;继承不能很好的解决问题,因为对象的行为在子类里不断地改变,并且让所有子类都有这些行为是不恰当的.
使用Fooable等接口,只用能实现的类才继承Fooable接口,但是java接口不具有实现代码,所以继承接口无法达到代码的复用.&lt;/p&gt;
&lt;p&gt;引出一个&lt;strong&gt;设计原则&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;找出应用中可能需要变化之处,把它独立出来,不要和那些不需要变化的代码混在一起&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;设计原则&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;针对接口编程,而不是针对实现编程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;假设有很多鸭子,有真鸭,模型鸭,如何实现他们的行为呢?&lt;/h1&gt;
&lt;h2&gt;先定义个一个抽象的Duck类&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 鸭子的抽象类
 */
public abstract  class Duck{
    private String _headColor=&quot;yellow&quot;;//Duck对象必备的属性

    public String get_headColor() {
        return _headColor;
    }

    public void set_headColor(String _headColor) {
        this._headColor = _headColor;
    }

    public IFlyBehavior flyBehavior;//为行为接口类型声明引用变量,所有鸭子子类都继承他们

    public IFlyBehavior getFlyBehavior() {
        return flyBehavior;
    }

    public void setFlyBehavior(IFlyBehavior flyBehavior) {
        this.flyBehavior = flyBehavior;
    }

    public IQuackBehavior getQuackBehavior() {
        return quackBehavior;
    }

    public void setQuackBehavior(IQuackBehavior quackBehavior) {
        this.quackBehavior = quackBehavior;
    }

    public IQuackBehavior quackBehavior;//同上

    public Duck(){

    }

    public void performQuack(){
        quackBehavior.quack();//委托给行为类
    }

    public void performFly(){
        flyBehavior.fly();//委托给行为类
    }

    public abstract void display();

    /**
     * Duck必备的行为
     */
    public void swim(){
        System.out.println(&quot;All ducks float,even decoys!&quot;);
    }

}&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;绿头鸭继承Duck&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 绿头鸭类
 */
public class MallardDuck extends Duck {
    public MallardDuck(){
        quackBehavior=new Quack();//绿头鸭使用Quack类处理叫,所以当performQuack()被调用时,叫的职责被委托给Quack
        flyBehavior=new FlyWithWings();//同理
    }

    public void display(){
        System.out.println(&quot;I'm a real Mallard duck&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;模型鸭&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;/*
* 模型鸭
*/
public class ModelDuck extends Duck {
    public ModelDuck(){
        flyBehavior=new FlyNoWay();//一开始,模型鸭不会飞
        quackBehavior=new Quack();//一开始,模型鸭会呱呱叫
    }
    @Override
    public void display() {

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;鸭子的鸣叫行为接口类&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;
/**
 * 叫行为接口类
 */
public interface IQuackBehavior{
    public void quack();
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;鸭子的飞行行为接口类&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 飞行行为接口类
 */
public interface IFlyBehavior{
    public void fly();
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;各种实现了飞行行为的实现类&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 这是飞行行为的实现,给真会飞的鸭子用
 */
public class FlyWithWings implements IFlyBehavior {
    @Override
    public void fly() {
        System.out.println(&quot;fly with wings&quot;);
    }
}

/**
 * 火箭动力的飞行行为
 */
public class FlyWithRocket implements IFlyBehavior {
    @Override
    public void fly() {
        System.out.println(&quot;I'm flying with a rocket!&quot;);
    }
}

/**
 * 这是飞行行为的实现,给不会飞的鸭子用
 */
public class FlyNoWay implements IFlyBehavior {
    @Override
    public void fly() {
        System.out.println(&quot;I can't fly!&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;各种实现了鸣叫行为的实现类&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 叫的实现,给会呱呱叫的鸭子用
 */
public class Quack implements IQuackBehavior {
    @Override
    public void quack() {
        System.out.println(&quot;Quack,gua gua gua!&quot;);
    }
}

/**
 * 鸭子叫的沉默实现,给不会叫的鸭子用
 */
public class QuackMute implements IQuackBehavior {
    @Override
    public void quack() {
        System.out.println(&quot;&amp;lt;&amp;lt;Silence&amp;gt;&amp;gt;&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;测试我们的鸭子们&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;public class Test {
    public static void main(String args[]){
        MallardDuck mallardDuck=new MallardDuck();
        mallardDuck.display();
        mallardDuck.performFly();
        mallardDuck.performQuack();

        //搞一只模型鸭
        ModelDuck md=new ModelDuck();
        md.performFly();//第一次调用飞行时,委托给FlyNoWay
        md.setFlyBehavior(new FlyWithRocket());//继承来的设置飞行模式的方法,给予火箭动力
        md.performFly();//现在能飞啦~

    }
}

//输出
Bobble gobble
I'm flying a short distance
gua!gua!gua!
I'm flying a long distance
Bobble gobble
I'm flying a short distance
I'm flying a short distance
I'm flying a short distance
I'm flying a short distance
I'm flying a short distance
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;项目地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jimersylee/DesignPattern&quot;&gt;java设计模式实现&lt;/a&gt;
如果觉得有点收获,记得在项目上点star哦!&lt;/p&gt;            </description>
            <pubDate>2017-09-12 10:01:04</pubDate>
            <link>//blog/java/design-pattern-interface.html</link>
            <guid isPermaLink="true">//blog/java/design-pattern-interface.html</guid>
                                               <category>java</category>
                                    </item>
                <item>
            <title>PHP源码安装扩展</title>
            <description>
            &lt;!--
author: Jimersy Lee
head: 
date: 2015-03-10
title: PHP源码安装扩展
tags: PHP
images: 
category: php
status: publish
summary: 本文介绍了如何使用PHP从源码安装扩展
--&gt;
&lt;h3&gt;环境:CentOS7,PHP5.3.6源码安装,APACHE服务器&lt;/h3&gt;
&lt;h3&gt;以安装mbstring扩展为例&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#切换到php源码目录中的扩展目录中的mbstring源码目录
cd /usr/src/php-5.3.6/ext/mbstring

#运行phpize
/usr/local/php/bin/phpize

#运行configure
./configure --with-php-config=/usr/local/php/bin/php-config

#编译和安装
make &amp;amp;&amp;amp; make install

#开启mbstring扩展
echo ‘extension=mbstring.so' &amp;gt;&amp;gt;/usr/local/php/lib/php.ini

#重启web服务器
/usr/local/apache2/bin/apachectl restart&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2017-09-12 10:01:04</pubDate>
            <link>//blog/php/php-install-ex-by-source-code.html</link>
            <guid isPermaLink="true">//blog/php/php-install-ex-by-source-code.html</guid>
                                               <category>php</category>
                                    </item>
                <item>
            <title>Linux快捷键</title>
            <description>
            &lt;!--
author: Jimersy Lee
head: 
date: 2014-11-14
title: Linux快捷键
tags: LINUX,SHORTCUT-KEY,CENTOS
images: 
category: linux
status: publish
summary: CentOS桌面版常用的快捷键,以及Linux常用命令
--&gt;
&lt;h1&gt;linux系统快捷键&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;
文件和目录:

# cd /home                        进入 '/home' 目录

# cd ..                                返回上一级目录

# cd ../..                             返回上两级目录

# cd -                                 返回上次所在目录

# cp file1 file2                    将file1复制为file2

# cp -a dir1 dir2                 复制一个目录

# cp -a /tmp/dir1 .              复制一个目录到当前工作目录（.代表当前目录）

# ls                                    查看目录中的文件

# ls -a                                显示隐藏文件

# ls -l                                 显示详细信息

# ls -lrt                               按时间显示文件（l表示详细列表，r表示反向排序，t表示按时间排序）

# pwd                                显示工作路径

# mkdir dir1                       创建 'dir1' 目录

# mkdir dir1 dir2                同时创建两个目录

# mkdir -p /tmp/dir1/dir2    创建一个目录树

# mv dir1 dir2                    移动/重命名一个目录

# rm -f file1                        删除 'file1'

# rm -rf dir1                       删除 'dir1' 目录及其子目录内容

查看文件内容:

# cat file1                          从第一个字节开始正向查看文件的内容

# head -2 file1                   查看一个文件的前两行

# more file1                       查看一个长文件的内容

# tac file1                          从最后一行开始反向查看一个文件的内容

# tail -3 file1                      查看一个文件的最后三行

文本处理:

# grep str /tmp/test            在文件 '/tmp/test' 中查找 &quot;str&quot;

# grep ^str /tmp/test           在文件 '/tmp/test' 中查找以 &quot;str&quot; 开始的行

# grep [0-9] /tmp/test         查找 '/tmp/test' 文件中所有包含数字的行

# grep str -r /tmp/*             在目录 '/tmp' 及其子目录中查找 &quot;str&quot;

# diff file1 file2                   找出两个文件的不同处

# sdiff file1 file2                 以对比的方式显示两个文件的不同

查找:

# find / -name file1                                                 从 '/' 开始进入根文件系统查找文件和目录

# find / -user user1                                                查找属于用户 'user1' 的文件和目录

# find /home/user1 -name \*.bin                            在目录 '/ home/user1' 中查找以 '.bin' 结尾的文件

# find /usr/bin -type f -atime +100                         查找在过去100天内未被使用过的执行文件

# find /usr/bin -type f -mtime -10                           查找在10天内被创建或者修改过的文件

# locate \*.ps                                                         寻找以 '.ps' 结尾的文件，先运行 'updatedb' 命令

# find -name '*.[ch]' | xargs grep -E 'expr'              在当前目录及其子目录所有.c和.h文件中查找 'expr'

# find -type f -print0 | xargs -r0 grep -F 'expr'        在当前目录及其子目录的常规文件中查找 'expr'

# find -maxdepth 1 -type f | xargs grep -F 'expr'    在当前目录中查找 'expr'

压缩和解压:

# bzip2 file1                                   压缩 file1

# bunzip2 file1.bz2                        解压 file1.bz2

# gzip file1                                     压缩 file1

# gzip -9 file1                                最大程度压缩 file1

# gunzip file1.gz                            解压 file1.gz

# tar -cvf archive.tar file1               把file1打包成 archive.tar

（-c: 建立压缩档案；-v: 显示所有过程；-f: 使用档案名字，是必须的，是最后一个参数）

# tar -cvf archive.tar file1 dir1        把 file1，dir1 打包成 archive.tar

# tar -tf archive.tar                         显示一个包中的内容

# tar -xvf archive.tar                      释放一个包

# tar -xvf archive.tar -C /tmp         把压缩包释放到 /tmp目录下

# zip file1.zip file1                          创建一个zip格式的压缩包

# zip -r file1.zip file1 dir1               把文件和目录压缩成一个zip格式的压缩包

# unzip file1.zip                             解压一个zip格式的压缩包到当前目录

# unzip test.zip -d /tmp/                 解压一个zip格式的压缩包到 /tmp 目录

yum工具:

# yum -y install [package]              下载并安装一个rpm包

# yum localinstall [package.rpm]    安装一个rpm包，使用你自己的软件仓库解决所有依赖关系

# yum -y update                              更新当前系统中安装的所有rpm包

# yum update [package]                 更新一个rpm包

# yum remove [package]                删除一个rpm包

# yum list                                        列出当前系统中安装的所有包

# yum search [package]                 在rpm仓库中搜寻软件包

# yum clean [package]                   清除缓存目录（/var/cache/yum）下的软件包

# yum clean headers                      删除所有头文件

# yum clean all                                删除所有缓存的包和头文件

网络:

# ifconfig eth0                                                                       显示一个以太网卡的配置

# ifconfig eth0 192.168.1.1 netmask 255.255.255.0            配置网卡的IP地址

# ifdown eth0                                                                        禁用 'eth0' 网络设备

# ifup eth0                                                                            启用 'eth0' 网络设备

# iwconfig eth1                                                                     显示一个无线网卡的配置

# iwlist scan                                                                         显示无线网络

# ip addr show                                                                     显示网卡的IP地址

其他:

# su -                                 切换到root权限（与su有区别）

# shutdown -h now           关机

# shutdown -r now            重启

# top                                  罗列使用CPU资源最多的linux任务 （输入q退出）

# pstree                             以树状图显示程序

# man ping                        查看参考手册（例如ping 命令）

# passwd                          修改密码

# df -h                               显示磁盘的使用情况

# cal -3                             显示前一个月，当前月以及下一个月的月历

# cal 10 1988                   显示指定月，年的月历

# date --date '1970-01-01 UTC 1427888888 seconds'   把一相对于1970-01-01 00:00的秒数转换成时间
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;桌面用快捷键&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;Ctrl + u            删除光标之前到行首的字符

Ctrl + k            删除光标之前到行尾的字符

Ctrl + c            取消当前行输入的命令，相当于Ctrl + Break

Ctrl + a            光标移动到行首（ahead of line），相当于通常的Home键

Ctrl + e            光标移动到行尾（end of line）

Ctrl + f             光标向前（forward）移动一个字符位置

Ctrl + b            光标往回（backward）移动一个字符位置

Ctrl + l             清屏，相当于执行clear命令

Ctrl + r            显示:号提示，根据用户输入查找相关历史命令（reverse-i-search）

Ctrl + w           删除从光标位置前到当前所处单词（word）的开头

Ctrl + t             交换光标位置前的两个字符

Ctrl + y            粘贴最后一次被删除的单词

Ctrl + Alt + d   显示桌面

Alt + b             光标往回（backward）移动到前一个单词

Alt + d             删除从光标位置到当前所处单词的末尾

Alt + F2           运行

Alt + F4           关闭当前窗口

Alt + F9           最小化当前窗口

Alt + F10         最大化当前窗口

Alt + Tab         切换窗口

Alt +按住左键  移动窗口（或在最下面的任务栏滚动鼠标滑轮）

[鼠标中间键] 粘贴突出显示的文本。使用鼠标左键来选择文本。把光标指向想粘贴文本的地方。点击鼠标中间键来粘贴。

[Tab] 命令行自动补全。使用 shell 提示时可使用这一方式。键入命令或文件名的前几个字符，然后按 [Tab] 键，它会自动补全命令或显示匹配键入字符的所有命令。

在桌面或文件管理器中直接按 / 就可以输入位置，打开文件管理器。

快速搜索：在 vi 或 Firefox 中直接按 / 即可进入搜索状态。

网站链接和图片可直接拖放到桌面或者目录，可以马上下载。

直接将文件管理器中的文件拖到终端中就可以在终端中得到完整的路径名。

在滚动条的空白处点击鼠标中键，屏幕即滚动到那个地方。&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2017-09-08 04:02:34</pubDate>
            <link>//blog/linux/centos-shortcut-key.html</link>
            <guid isPermaLink="true">//blog/linux/centos-shortcut-key.html</guid>
                                               <category>linux</category>
                                    </item>
                <item>
            <title>养成好习惯</title>
            <description>
            &lt;!--
author: Jimersy Lee
head: 
date: 2014-08-20
title: 养成好习惯
tags: Blog
images: 
category: 
status: publish
summary: &gt;安装了一个新的app 叫微习惯 督促自己每天都做一些事
--&gt;
&lt;p&gt;安装了一个新的app 叫微习惯 督促自己每天都做一些事
今天努力完成了所有小事 就差一个30分钟的写作了
于是现在在写
每做完一件事然后打勾 还是很有成就感的
父母在我很小的时候就教育我 说人生最难的就是坚持 小时候不以为意 现在明白了 人都是倾向于虎头蛇尾的 坚持的确是件最难的事
但是 我希望可以改变 可以从一个个的小习惯开始 改变自己
加油
明天早点起床&lt;/p&gt;            </description>
            <pubDate>2017-09-08 04:02:34</pubDate>
            <link>//blog/thoughts/20140820-good-habbit.html</link>
            <guid isPermaLink="true">//blog/thoughts/20140820-good-habbit.html</guid>
                    </item>
                <item>
            <title>游泳杂感</title>
            <description>
            &lt;!--
author: Jimersy Lee
head: 
date: 2014-07-23
title: 游泳杂感
tags: BLOG
images: 
category: thoughts
status: publish
summary: 游泳杂感
--&gt;
&lt;p&gt;七月二十三日， 晴，热。&lt;/p&gt;
&lt;p&gt;于是去游泳。&lt;/p&gt;
&lt;p&gt;一个人，一条裤衩，不戴泳镜，更不需要救生圈。
地点是泄洪坝底下下冲刷而成的水潭，虽没有桃花潭水深千尺，但是十尺还是有的。前几日连绵大雨，所以泄洪了，于是水潭中都是新鲜的水库水，经过水的冲刷，现在水底很清澈，可以直接看到水底。也没有水藻。非常适合游泳呐。
在靠近岸边的地方下水，岸边还是很浅的，踩着圆润的水底砂石，仿佛有种回到童年的感觉。那个瘦瘦小小的小孩，双手撑在河底，双脚扑腾着学习游泳的小孩。嘴巴进水，鼻子进水，咳嗽，鼻酸，长时间潜水后强烈想要呼吸的感觉，潜到深处胸腔感受到的压力，以及水中唯一听得到的隆隆声，虽历历在目，声声在耳，却是多久没感受过了。&lt;/p&gt;
&lt;p&gt;自由泳，蛙泳，仰泳，潜泳，狗刨式，全部来一套。原来游泳这个技能，一旦学会，就完全不会忘呢。什么学会呢，先天技能，幼时就在子宫里游来游去。
水底的世界就像是近视眼看到的世界一样，模糊，但是色彩斑斓。尤其对白色的物体尤为敏感。白色的石头，闪着光。随意潜入水中，就可以捞起一些石头，这是幼时最喜爱的游泳游戏。可是现在，却没有幼时的欣喜。&lt;/p&gt;            </description>
            <pubDate>2017-09-08 04:02:34</pubDate>
            <link>//blog/thoughts/20140723.html</link>
            <guid isPermaLink="true">//blog/thoughts/20140723.html</guid>
                                               <category>thoughts</category>
                                    </item>
                <item>
            <title>CentOS7安装Jenkins</title>
            <description>
            &lt;!--
author: Jimersy Lee
head: 
date: 2014-01-01
title: CentOS7安装Jenkins
tags: CENTOS,JENKINS
images: 
category: devops
status: publish
summary: 本文展示了如何在CentOS上通过yum安装jenkins,而不是使用war包,以及tomcat容器启动jenkins
--&gt;
&lt;p&gt;环境:CentOS7&lt;/p&gt;
&lt;p&gt;1.下载安装包
在https://jenkins.io/download/找到相应的包下载地址&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget https://pkg.jenkins.io/redhat/jenkins-2.76-1.1.noarch.rpm&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.安装包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo rpm -i jenkins-2.76-1.1.noarch.rpm&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.启动jenkins&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo service jenkins start&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.配置nginx&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim /etc/nginx/conf.d/jenkins.conf
server {
 2         listen       443;
 3         server_name  jenkins.jimersylee.com;
 4         ssl on;
 5         ssl_certificate /data/ssl_cert/Nginx/1_jimersylee.com_bundle.crt;
 6         ssl_certificate_key /data/ssl_cert/Nginx/2_jimersylee.com.key;
 7         ssl_session_timeout 5m;
 8         ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置
 9         ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置
10         ssl_prefer_server_ciphers on;
11        # root /data/www/www;

12
13         index index.html index.htm index.php;
14         location /
15         {
16             proxy_pass http://127.0.0.1:8080;
17         }
18
19         access_log /data/logs/jenkins/jenkins.log main;
20         }
21
22 server {
23     listen 80;
24     server_name jenkins.jimersylee.com;
25     rewrite ^ https://$server_name$request_uri? permanent;
26     }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.访问https://jenkins.jimersylee.com/
发现没有账号密码,修改jenkins为不需要账号密码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim /var/lib/jenkins/config.xml
&amp;lt;useSecurity&amp;gt;true&amp;lt;/useSecurity&amp;gt;修改为false
重启jenkins
sudo service jenkins restart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6.访问https://jenkins.jimersylee.com/
系统管理-&amp;gt;Configure Global Security 勾选启用安全,勾选使用jenkins专有数据库&lt;/p&gt;
&lt;p&gt;7.因为要使用某个特定账号如dev去执行shell,因此将jenkins的默认启动账号jenkins修改为dev&lt;/p&gt;
&lt;p&gt;8.如何修改运行jenkins进程的linux帐号？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;找到jenkins的配置文件，一般是/etc/sysconfig/jenkins&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;修改下面的参数为相应的用户，比如JENKINS_USER=&amp;quot;dev&amp;quot;
&lt;pre&gt;&lt;code&gt;## Type:        string
## Default:     &quot;jenkins&quot;
## ServiceRestart: jenkins
#
# Unix user account that runs the Jenkins daemon
# Be careful when you change this, as you need to update
# permissions of $JENKINS_HOME and /var/log/jenkins.
#
JENKINS_USER=&quot;dev&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改下来文件或目录的权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chown dev:dev file
chown -R admin:admin directory
/var/lib/jenkins/
/var/log/jenkins/
/var/cache/jenkins/
/usr/lib/jenkins/jenkins.war
/etc/sysconfig/jenkins&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;重启jenkins：service jenkins restart&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;通过war包安装&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;安装tomcat
mkdir /data/java_app/jenkins &amp;amp;&amp;amp; cd /data/java_app/jenkins&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;wget &lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-9/v9.0.0.M26/bin/apache-tomcat-9.0.0.M26.zip&quot;&gt;https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-9/v9.0.0.M26/bin/apache-tomcat-9.0.0.M26.zip&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;unzip apache-tomcat-9.0.0.M26.zip
mv apache-tomcat-9.0.0.M26 tomcat9
cd tomcat9/webapps
wget &lt;a href=&quot;http://mirrors.jenkins.io/war/latest/jenkins.war&quot;&gt;http://mirrors.jenkins.io/war/latest/jenkins.war&lt;/a&gt;
cd ../bin
sh catalina.sh&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;
&lt;p&gt;访问127.0.0.1:8080/jenkins&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要输入初始密码
cat /home/username/.jenkins/secrets/initialAdminPassword&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;然后配置插件什么的&lt;/li&gt;
&lt;/ol&gt;            </description>
            <pubDate>2017-09-04 23:02:45</pubDate>
            <link>//blog/devops/InstallJenkinsOnCentOS7.html</link>
            <guid isPermaLink="true">//blog/devops/InstallJenkinsOnCentOS7.html</guid>
                                               <category>devops</category>
                                    </item>
                <item>
            <title>Hello World</title>
            <description>
            &lt;!--
author: Jimersy Lee
head: 
date: 2014-01-01
title: Hello World
tags: Blog
images: 
category: 
status: publish
summary: 本人精通各种编程语言              的hello world!
--&gt;
&lt;h1&gt;Hello World&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;本人精通各种语言              的hello world!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;echo &quot;hello world&quot;;
printf &quot;hello world&quot;;
System.out.println(&quot;hello world&quot;);
print(&quot;hello world&quot;)
alert(&quot;hello world&quot;);
std::cout &amp;lt;&amp;lt; &quot;hello world&quot; &amp;lt;&amp;lt; std::endl;
Console.WriteLine(&quot;hello world&quot;); 
&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2017-09-03 08:34:23</pubDate>
            <link>//blog/HelloWorld.html</link>
            <guid isPermaLink="true">//blog/HelloWorld.html</guid>
                    </item>
            </channel>
</rss>